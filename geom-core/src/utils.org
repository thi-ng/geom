#+SETUPFILE: ../../src/setup.org

* Contents                                                         :toc_4_gh:
 - [[#namespace-thinggeomcoreutils][Namespace: thi.ng.geom.core.utils]]
     - [[#point-collection-functions][Point collection functions]]
         - [[#distance--length][Distance & length]]
         - [[#centroid--centering][Centroid & centering]]
         - [[#area--volume][Area & volume]]
         - [[#bounds][Bounds]]
         - [[#sampling][Sampling]]
         - [[#interpolation][Interpolation]]
         - [[#tessellation][Tessellation]]
     - [[#normals][Normals]]
     - [[#triangles][Triangles]]
     - [[#complete-namespace-definition][Complete namespace definition]]

* Namespace: thi.ng.geom.core.utils

** Point collection functions

*** Distance & length

#+BEGIN_SRC clojure :noweb-ref dist
  (defn closest-point-coeff
    [p a b]
    (let [d (m/- b a)]
      (/ (m/dot (m/- p a) d) (m/mag-squared d))))

  (defn closest-point-on-line
    [p a b]
    (m/mix a b (closest-point-coeff p a b)))

  (defn closest-point-on-segment
    [p a b]
    (let [t (closest-point-coeff p a b)]
      (if (<= t 0.0) a (if (>= t 1.0) b (m/mix a b t)))))

  (defn closest-point-on-segments
    [p segments]
    (transduce
     (map #(apply closest-point-on-segment p %))
     (completing
      (fn [a q]
        (let [d' (g/dist-squared p q)]
          (if (< d' (a 1)) [q d'] a))))
     [nil m/INF+]
     segments))

  (defn closest-line-between
    [a1 b1 a2 b2]
    (let [p43 (m/- b2 a2)]
      (if-not (m/delta= V3 p43 *eps*)
        (let [p21 (m/- b1 a1)]
          (if-not (m/delta= V3 p21 *eps*)
            (let [p13   (m/- a1 a2)
                  d1343 (m/dot p13 p43)
                  d4321 (m/dot p43 p21)
                  d1321 (m/dot p13 p21)
                  d4343 (m/dot p43 p43)
                  d2121 (m/dot p21 p21)
                  d     (mm/msub d2121 d4343 d4321 d4321)]
              (if (m/delta= 0.0 d *eps*)
                {:type :parallel}
                (let [n  (mm/msub d1343 d4321 d1321 d4343)
                      ua (/ n d)
                      ub (/ (mm/madd d4321 ua d1343) d4343)]
                  {:type :intersect
                   :a    (m/madd p21 ua a1)
                   :b    (m/madd p43 ub a2)
                   :ua   ua
                   :ub   ub}))))))))

  (defn dist*
    [rf]
    (fn [c points]
      (->> points
           (transduce (map #(g/dist-squared c %)) rf 0)
           (Math/sqrt))))

  (def min-dist (dist* min))
  (def max-dist (dist* max))

  (defn arc-length-index
    [points]
    (->> points
         (partition 2 1)
         (transduce
          (map #(g/dist (% 0) (% 1)))
          (completing (fn [a d] (conj a (+ (peek a) d))))
          [0])))

  (defn arc-length
    [points]
    (d/reduce-pairs + g/dist points))
#+END_SRC

*** Centroid & centering

#+BEGIN_SRC clojure :noweb-ref center
  (defn centroid
    [coll]
    (case (count coll)
      0 nil
      1 (first coll)
      2 (m/mix (first coll) (nth coll 1))
      (let [s (/ 1.0 (count coll))
            f (fn [x _] (* x s))]
        (g/reduce-vector (first coll) + f (rest coll)))))

  (defn center
    ([c' coll]
       (center (centroid coll) c' coll))
    ([c c' coll]
       (let [d (m/- c' c)] (mapv #(m/+ % d) coll))))

  (defn scale-size
    ([s coll] (scale-size (centroid coll) s coll))
    ([c s coll] (mapv #(m/madd (m/- % c) s c) coll)))
#+END_SRC

*** Area & volume

Volume calculation is using [[file:triangle.org::*Triangle3][signed volume implementation of Triangle3]].

#+BEGIN_SRC clojure :noweb-ref area-volume
  (defn- tessellating-transducer
    [f]
    (comp
     (mapcat tessellate-with-first)
     (map f)))

  (def ^:private area-xf
    (tessellating-transducer #(->> % (apply tri-area3) m/abs*)))

  (def ^:private volume-xf
    (tessellating-transducer #(m/dot (% 0) (m/cross (% 1) (% 2)))))

  (defn total-area-3d
    ([faces] (transduce area-xf + faces))
    ([xf faces] (transduce (comp xf area-xf) + faces)))

  (defn total-volume
    ([faces] (/ (transduce volume-xf + faces) 6.0))
    ([xf faces] (/ (transduce (comp xf volume-xf) + faces) 6.0)))
#+END_SRC

*** Bounds

#+BEGIN_SRC clojure :noweb-ref bounds
  (defn bounds*
    [zero coll]
    (let [c (count coll)]
      (cond
        (> c 1) (let [[x & xs] coll
                      p (g/reduce-vector x min xs)
                      q (g/reduce-vector x max xs)]
                  [p (m/- q p)])
        (== c 1) [(first coll) zero]
        :default nil)))

  (defn bounding-rect
    [points]
    (bounds* V2 points))

  (defn bounding-box
    [points]
    (bounds* V3 points))

  (defn radial-bounds
    [ctor c r-or-points]
    [(ctor c)
     (if (coll? r-or-points)
       (max-dist c r-or-points)
       r-or-points)])

  (defn axis-bounds
    [axis coll]
    (let [xs (mapv #(nth % axis) coll)]
      [(reduce min xs) (reduce max xs)]))

  (defn axis-range
    [axis coll]
    (- (apply - (axis-bounds axis coll))))

  (defn delta-contains
    [points p eps]
    (some #(m/delta= p % eps) points))
#+END_SRC

*** Sampling

#+BEGIN_SRC clojure :noweb-ref sample
  (defn from-barycentric
    [points weights]
    (reduce m/+ (map m/* points weights)))

  (defn point-at*
    [points idx total t i]
    (let [ct (* t total)
          i (int (loop [i i] (if (>= ct (idx i)) (recur (inc i)) i)))
          i1 (dec i)
          pi (idx i1)]
      [(m/mix (nth points i1) (nth points i)
              (mm/subdiv ct pi (idx i) pi))
       i]))

  (defn point-at
    ([t points] (point-at t points nil))
    ([t points idx]
       (when (m/in-range? 0.0 1.0 t)
         (let [n (count points)
               t (double t)]
           (cond
            (== 0 n) nil
            (== 1 n) (first points)
            (== 1.0 t) (last points)
            :default
            (let [idx (or idx (arc-length-index points))]
              (first (point-at* points idx (peek idx) t 1))))))))

  (defn sample-uniform*
    [udist include-last? points]
    (let [idx (arc-length-index points)
          total (peek idx)
          delta (/ udist total)
          samples (loop [t 0.0, i 1, acc []]
                    (if (< t 1.0)
                      (let [[p i] (point-at* points idx total t i)]
                        (recur (+ t delta) (int i) (conj acc p)))
                      acc))]
      (if include-last?
        (conj samples (last points))
        samples)))

  (defn sample-uniform
    [udist include-last? points]
    (let [n (count points)]
      (cond
       (== 0 n) nil
       (== 1 n) [(first points)]
       :default (sample-uniform* udist include-last? points))))

  (defn sample-segment-with-res
    [a b res include-b?]
    (let [ls (for [t (m/norm-range res)] (m/mix a b t))]
      (if include-b? ls (butlast ls))))
#+END_SRC

*** Interpolation

  : d +----+ c
  :   |    |
  :   |    |
  : a +----+ b

#+BEGIN_SRC clojure :noweb-ref interpolate
  (defn map-bilinear
    "Takes a seq of 4 points in ccw order and 2D vector of normalized UV
    coordinates. Applies bilinear interpolation to compute point within
    the rect: U is coord along AB/DC edge, V along BC/AD"
    [[a b c d] [u v]]
    (m/mix a b d c u v))
#+END_SRC

  : e +----+ h
  :   |\   :\
  :   |f+----+ g
  :   | |  : |
  : a +-|--+d|
  :    \|   \|
  :   b +----+ c

#+BEGIN_SRC clojure :noweb-ref interpolate
  (defn map-trilinear
    "Takes a seq of 8 points defining a cuboid and vector of normalized
    UVW coordinates. Applies trilinear interpolation to compute point
    within the cuboid: U is coord along AD/BC edge, V along AE/BF, W
    along AB/DC (see above diagram)"
    [[a b c d e f g h] [u v w]]
    (m/mix (m/mix a d e h u v) (m/mix b c f g u v) w))
#+END_SRC

*** Tessellation

#+BEGIN_SRC clojure :noweb-ref tessellate
  (defn tessellate-with-point
    ([points] (tessellate-with-point (centroid points) points))
    ([c points]
     (->> [(first points)]
          (concat points)
          (partition 2 1)
          (mapv #(vector c (first %) (nth % 1))))))

  (defn tessellate-with-first
    [points]
    (if (> (count points) 3)
      (let [v0 (first points)]
        (mapv (fn [[a b]] [v0 a b]) (partition 2 1 (rest points))))
      [points]))

  (defn tessellate-tri-with-midpoints
    [[a b c]]
    (let [ab (m/mix a b)
          bc (m/mix b c)
          ca (m/mix c a)]
      [[a ab ca] [ab b bc] [bc c ca] [ab bc ca]]))

  (defn tessellate-3
    [points]
    (condp == (count points)
      3 [points]
      4 (let [[a b c d] points] [[a b c] [a c d]])
      (tessellate-with-point points)))

  (defn tessellate-max4
    [points]
    (if (<= (count points) 4)
      [points]
      (tessellate-with-point points)))

  (defn tessellate-face
    [tess-fn]
    (fn [[verts attribs]]
      (let [verts (tess-fn verts)
            attribs (reduce-kv
                     (fn [acc k v] (assoc acc k (tess-fn v)))
                     {} attribs)]
        (map-indexed
         (fn [i verts]
           [verts (reduce-kv (fn [acc k v] (assoc acc k (nth v i))) {} attribs)])
         verts))))
#+END_SRC

** Normals

#+BEGIN_SRC clojure :noweb-ref normals
  (defn ortho-normal
    ([[a b c]] (m/normalize (m/cross (m/- b a) (m/- c a))))
    ([a b] (m/normalize (m/cross a b)))
    ([a b c] (m/normalize (m/cross (m/- b a) (m/- c a)))))
#+END_SRC

** Triangles

#+BEGIN_SRC clojure :noweb-ref triangles
  (defn norm-sign2
    [[ax ay] [bx by] [cx cy]]
    (- (mm/subm bx ax cy ay) (mm/subm cx ax by ay)))

  (defn norm-sign3
    [a b c] (m/mag (m/cross (m/- b a) (m/- c a))))

  (defn tri-area2
    [a b c] (* 0.5 (norm-sign2 a b c)))

  (defn tri-area3
    [a b c] (* 0.5 (norm-sign3 a b c)))

  (defn clockwise2?
    [a b c] (neg? (norm-sign2 a b c)))

  (defn clockwise3?
    [a b c n] (pos? (m/dot (m/cross (m/- b a) (m/- c a)) n)))

  (defn triangle-barycentric-coords
    ([[a b c] p]
       (triangle-barycentric-coords a b c p (m/- b a) (m/- c a)))
    ([a b c p]
       (triangle-barycentric-coords a b c p (m/- b a) (m/- c a)))
    ([a b c p u v]
       (let [w (m/- p a)
             uu (m/mag-squared u)
             vv (m/mag-squared v)
             uv (m/dot u v)
             wu (m/dot w u)
             wv (m/dot w v)
             denom (/ 1.0 (mm/msub uv uv uu vv))
             s (* denom (mm/msub uv wv vv wu))
             t (* denom (mm/msub uv wu uu wv))]
         [(- 1.0 (+ s t)) s t])))

  (defn point-in-triangle2?
    [p a b c]
    (if (clockwise2? a b c)
      (and (>= (norm-sign2 a c p) 0.0)
           (>= (norm-sign2 b a p) 0.0)
           (>= (norm-sign2 c b p) 0.0))
      (and (>= (norm-sign2 b c p) 0.0)
           (>= (norm-sign2 a b p) 0.0)
           (>= (norm-sign2 c a p) 0.0))))

  (defn point-in-triangle3?
    [p a b c]
    (let [u (m/- b a)
          v (m/- c a)
          n (ortho-normal u v)
          cl (- (m/dot n p) (m/dot n a))]
      (if (m/delta= 0.0 cl)
        (let [[u v w] (triangle-barycentric-coords a b c p u v)]
          (and (>= u 0.0) (>= w 0.0) (m/in-range? 0.0 1.0 v))))))
#+END_SRC

** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../babel/src/thi/ng/geom/core/utils.cljc :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.core.utils
    #?(:cljs
       (:require-macros
        [thi.ng.math.macros :as mm]))
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.geom.core.vector :as v :refer [vec2 vec3 V2 V3]]
     [thi.ng.dstruct.core :as d]
     [thi.ng.math.core :as m :refer [*eps*]]
     [clojure.core.reducers :as r]
     #?(:clj [thi.ng.math.macros :as mm])))

  (declare tri-area3)

  <<dist>>

  <<center>>

  <<bounds>>

  <<sample>>

  <<interpolate>>

  <<tessellate>>

  <<normals>>

  <<triangles>>

  <<area-volume>>
#+END_SRC
