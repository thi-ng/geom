#+SETUPFILE: ../../src/setup.org

* Contents                                                         :toc_4_gh:
 - [[#namespace-thinggeomtypesutils][Namespace: thi.ng.geom.types.utils]]
     - [[#bounds][Bounds]]
     - [[#meshes][Meshes]]
     - [[#complete-namespace-definition][Complete namespace definition]]

* Namespace: thi.ng.geom.types.utils

** Bounds

#+BEGIN_SRC clojure :noweb-ref bounds
  (defn bounding-rect
    [points]
    (let [[p size] (gu/bounding-rect points)]
      (if p (thi.ng.geom.types.Rect2. p size))))
  
  (defn bounding-box
    [points]
    (let [[p size] (gu/bounding-box points)]
      (if p (thi.ng.geom.types.AABB. p size))))
  
  (defn bounding-circle
    ([points]
       (bounding-circle (gu/centroid points) points))
    ([c r-or-points]
       (let [[c r] (gu/radial-bounds vec2 c r-or-points)]
         (thi.ng.geom.types.Circle2. c r))))
  
  (defn bounding-sphere
    ([points]
       (bounding-sphere (gu/centroid points) points))
    ([c r-or-points]
       (let [[c r] (gu/radial-bounds vec3 c r-or-points)]
         (thi.ng.geom.types.Sphere. c r))))
  
  (defn coll-bounds
    "Takes a seq of shape entities, calls g/bounds on each and returns
    union bounds. Does not support collections of mixed 2d/3d entities."
    [coll]
    (reduce m/union (mapv g/bounds coll)))
  
  (defn fit-all-into-bounds
    "Takes an AABB or rect and seq of shapes, proportionally scales and
    repositions all items to fit into given bounds. Returns lazyseq of
    transformed entities. Does not support collections of mixed 2D/3D
    entities. Use rects as target bounds for 2D colls."
    [bounds coll]
    (let [b (coll-bounds coll)
          s (reduce min (m/div (:size bounds) (:size b)))
          b' (g/center (g/scale b s) (g/centroid bounds))]
      (map
       #(-> %
            (g/center (g/unmap-point b' (g/map-point b (g/centroid %))))
            (g/scale-size s))
       coll)))
#+END_SRC

** Meshes

#+BEGIN_SRC clojure :noweb-ref meshes
  (defn into-mesh
    "Takes a target mesh, its add-face fn and a source mesh or face
    sequence. Adds faces to target mesh and returns it."
    [mesh add-face mesh-or-faces]
    (reduce
     add-face
     mesh
     (if (satisfies? g/IFaceAccess mesh-or-faces)
       (g/faces mesh-or-faces true)
       mesh-or-faces)))

  (defn map-mesh
    "Applies f to all faces of given mesh and adds resulting faces to
    new mesh. Thus f should return a seq of raw faces (i.e. each face as
    2-elem vector of [verts attribs]. Returns new mesh."
    [f mesh] (g/into (g/clear* mesh) (mapcat f (g/faces mesh true))))

  ;; TODO how to use this w/ IndexedMesh? Faces only store vertex IDs
  (defn transform-mesh
    "Takes a mesh, its add-face fn and a vertex transformation fn.
    Transforms all mesh vertices and returns new mesh."
    [mesh add-face tx]
    (let [tx     (if (satisfies? g/IVectorTransform tx)
                   (fn [v] (g/transform-vector tx v))
                   tx)
          verts' (->> (g/vertices mesh)
                      (reduce
                       (fn [acc v] (assoc! acc v (tx v)))
                       (transient (hash-map)))
                      (persistent!))]
      (reduce
       (fn [mesh [fv fa]] (add-face mesh [(mapv verts' fv) fa]))
       (g/clear* mesh) (g/faces mesh true))))
#+END_SRC

** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../babel/src/thi/ng/geom/types/utils.cljc :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.types.utils
    (:require
     [thi.ng.math.core :as m]
     [thi.ng.geom.core :as g]
     [thi.ng.geom.core.utils :as gu]
     [thi.ng.geom.core.vector :as v :refer [vec2 vec3]]
     [thi.ng.geom.types]
     [clojure.core.reducers :as r]))

  <<bounds>>

  <<meshes>>
#+END_SRC
