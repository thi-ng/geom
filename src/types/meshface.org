#+SETUPFILE: ../../meta/setup.org

* Contents                                                         :toc_4_gh:
 - [[#namespace-thinggeommeshface][Namespace: thi.ng.geom.meshface]]
     - [[#meshface][MeshFace]]
     - [[#indexedmeshface][IndexedMeshFace]]
     - [[#helpers][Helpers]]
     - [[#complete-namespace-definition][Complete namespace definition]]

* Namespace: thi.ng.geom.meshface

** MeshFace

#+BEGIN_SRC clojure :noweb-ref plain
  (deftype MeshFace
      [vertices
       #?@(:clj [^:unsynchronized-mutable _hash]
           :cljs [^:mutable _hash])]
    g/IVertexAccess
    (vertices
     ([_] vertices)
     ([_ _] vertices))
    g/IAttributeAccess
    (attribs [_ _] nil)
    g/IRawAccess
    (raw [_ _] [vertices])
    Object
    (toString [_] (str \[ vertices \]))
    #?@(:clj
        [(hashCode [_] (or _hash (set! _hash (.hashCode vertices))))
         (equals
          [_ o]
          (and (instance? MeshFace o)
               (clojure.lang.Util/equals vertices (.-vertices ^MeshFace o))))
         Comparable
         (compareTo [_ o] (compare vertices (.-vertices ^MeshFace o)))
         clojure.lang.IHashEq
         (hasheq [_] (.hashCode _))]
        :cljs
        [IHash
         (-hash [_] (or _hash (set! _hash (hash vertices))))
         IComparable
         (-compare [_ o] (compare vertices (.-vertices ^MeshFace o)))]))
#+END_SRC

** IndexedMeshFace

#+BEGIN_SRC clojure :noweb-ref plain
  (deftype IndexedMeshFace
      [vertices attribs
       #?@(:clj [^:unsynchronized-mutable _hash]
           :cljs [^:mutable _hash])]
    g/IVertexAccess
    (vertices [_ mesh]
      (let [idx (-> mesh :vertices :id->v)]
        (mapv #(get idx %) vertices)))
    g/IAttributeAccess
    (attribs [_ mesh]
      (let [mattr (get mesh :attribs)]
        (reduce-kv
         (fn [acc k v]
           (let [idx (-> mattr (get k) (get :id->v))]
             (assoc acc k (if (sequential? v) (mapv #(get idx %) v) (get idx v)))))
         {} attribs)))
    (attribs [_ mesh attr]
      (let [idx  (-> mesh (get :attribs) (get attr) (get :id->v))
            aval (attribs attr)]
        (if (sequential? aval) (mapv idx attribs) (idx aval))))
    g/IRawAccess
    (raw [_ mesh]
      [(g/vertices _ mesh) (g/attribs _ mesh)])
    Object
    (toString [_]
      (str \[ vertices \space attribs \]))
    #?@(:clj
        [(hashCode
          [_]
          (or _hash
              (set! _hash
                    (unchecked-add-int
                     (unchecked-multiply-int (.hashCode vertices) 31)
                     (.hashCode attribs)))))
         (equals
          [_ o]
          (and (instance? IndexedMeshFace o)
               (clojure.lang.Util/equals vertices (.-vertices ^IndexedMeshFace o))
               (clojure.lang.Util/equals attribs (.-attribs ^IndexedMeshFace o))))
         Comparable
         (compareTo
          [_ o]
          (let [c (compare vertices (.-vertices ^IndexedMeshFace o))]
            (if (zero? c)
              (compare attribs (.-attribs ^IndexedMeshFace o))
              c)))
         clojure.lang.IHashEq
         (hasheq [_] (.hashCode _))]
        :cljs
        [IHash
         (-hash
          [_]
          (or _hash
              (set! _hash
                    (-> (hash vertices)
                        (imul 31)
                        (+ (hash attribs))
                        (bit-or 0)))))
         IComparable
         (-compare
          [_ o]
          (let [c (compare vertices (.-vertices ^IndexedMeshFace o))]
            (if (zero? c)
              (compare attribs (.-attribs ^IndexedMeshFace o))
              c)))])
    )
#+END_SRC

** Helpers

#+BEGIN_SRC clojure :noweb-ref helpers
  (defn xf-face-verts
    [mesh] (map #(first (g/raw % mesh))))
#+END_SRC

** Complete namespace definition

#+BEGIN_SRC clojure :tangle ../../babel/src/thi/ng/geom/meshface.cljc :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.meshface
    (:require
     [thi.ng.geom.core :as g]
     [thi.ng.geom.vector :as v :refer [vec2 vec3]]))

  <<helpers>>

  <<plain>>

  <<indexed>>
#+END_SRC
