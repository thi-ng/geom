#+SETUPFILE: ../../meta/setup.org

* Contents                                                         :toc_4_gh:
 - [[#namespace-thinggeompath][Namespace: thi.ng.geom.path]]
     - [[#todo-add-path-builder][TODO add path builder]]
     - [[#constructor][Constructor]]
     - [[#path-segment-processing][Path segment processing]]
         - [[#todo-refactor-to-use-protocols][TODO refactor to use protocols]]
     - [[#svg-path-parser][SVG path parser]]
     - [[#svg-path-parser-clojure-only][SVG path parser (Clojure only)]]
     - [[#protocol-implementations][Protocol implementations]]
         - [[#todo-iarea][TODO IArea]]
         - [[#todo-iboundary][TODO IBoundary]]
         - [[#todo-ibounds][TODO IBounds]]
         - [[#todo-iboundingcircle][TODO IBoundingCircle]]
         - [[#todo-icenter][TODO ICenter]]
         - [[#todo-icircumference][TODO ICircumference]]
         - [[#todo-igraph][TODO IGraph]]
         - [[#todo-ipolygonconvert][TODO IPolygonConvert]]
         - [[#todo-isample][TODO ISample]]
         - [[#end-of-implementation][End of implementation]]
     - [[#namespace-declaration][Namespace declaration]]

* Namespace: thi.ng.geom.path

** TODO add path builder
#+BEGIN_SRC clojure
  (build-path
   (moveto [0 0])
   (lineto 100 0)
   (curveto a b c)
   (close))
#+END_SRC

** Constructor
#+BEGIN_SRC clojure :noweb-ref ctors
  (defn path2
    ([segments]
       (thi.ng.geom.types.Path2. (vec segments)))
    ([s1 s2 & segments]
       (thi.ng.geom.types.Path2. (vec (cons s1 (cons s2 segments))))))
#+END_SRC

** Path segment processing
*** TODO refactor to use protocols
#+BEGIN_SRC clojure :noweb-ref parser
  (defmulti sample-segment (fn [s res last?] (get s :type)))

  (defmethod sample-segment :line
    [{[a b] :points} res last?]
    (gu/sample-segment-with-res a b res last?))

  (defmethod sample-segment :close
    [{[a b] :points} res last?]
    (gu/sample-segment-with-res a b res last?))

  (defmethod sample-segment :bezier
    [{points :points} res last?]
    (b/sample-with-res res last? points))

  (defn sample-segments*
    [res segments]
    (let [last (last segments)
          [paths curr] (reduce
                        (fn [[paths curr] seg]
                          (let [curr (concat curr (sample-segment seg res (= seg last)))]
                            (if (= :close (get seg :type))
                              [(conj paths curr) []]
                              [paths curr])))
                        [[] []] segments)]
      (if (seq curr)
        (conj paths curr)
        paths)))
#+END_SRC

** SVG path parser

#+BEGIN_SRC clojure :noweb-ref parser
  (defn parse-svg-coords
    [coords]
    (->> coords
         (re-seq #"[0-9\.\-\+]+")
         #?(:clj (map #(Double/parseDouble %)) :cljs (map js/parseFloat))
         (partition 2)
         (mapv vec2)))

  (defn parse-svg-path
    ([svg]
     (parse-svg-path
      (->> svg
           (re-seq #"([MLCZz])\s*(((([0-9\.\-]+)\,?){2}\s*){0,3})")
           (map (fn [[_ t c]]
                  [t (parse-svg-coords c)])))
      [0 0] [0 0]))
    ([[[type points :as seg] & more] p0 pc]
     (when seg
       (cond
         (= "M" type)
         (let [p (first points)] (recur more p p))

         (= "L" type)
         (let [p (first points)]
           (lazy-seq (cons {:type :line :points [pc p]}
                           (parse-svg-path more p0 p))))

         (= "C" type)
         (let [p (last points)]
           (lazy-seq (cons {:type :bezier :points (cons pc points)}
                           (parse-svg-path more p0 p))))

         (or (= "Z" type) (= "z" type))
         (lazy-seq (cons {:type :close :points [pc p0]}
                         (parse-svg-path more p0 p0)))

         :default
         (err/unsupported! (str "Unsupported path segment type" type))))))
#+END_SRC

** SVG path parser (Clojure only)
#+BEGIN_SRC clojure :noweb-ref parser
  #?(:clj
     (defn parse-svg
       [src res udist]
       (->> src
            (xml/parse)
            (xml-seq)
            (filter #(= :path (get % :tag)))
            (mapv #(parse-svg-path (-> % (get :attrs) (get :d))))
            (map path2))))
#+END_SRC

** Protocol implementations

#+BEGIN_SRC clojure :noweb-ref impl
  (extend-type thi.ng.geom.types.Path2
#+END_SRC

*** TODO IArea
#+BEGIN_SRC clojure :noweb-ref impl
  g/IArea
  (area [_])
#+END_SRC

*** TODO IBoundary
#+BEGIN_SRC clojure :noweb-ref impl
  g/IClassify
  (classify-point [_ p])
  g/IProximity
  (closest-point [_ p])
  g/IBoundary
  (contains-point? [_ p])
#+END_SRC

*** TODO IBounds
#+BEGIN_SRC clojure :noweb-ref impl
  g/IBounds
  (bounds [_])
#+END_SRC

*** TODO IBoundingCircle
#+BEGIN_SRC clojure :noweb-ref impl
  g/IBoundingCircle
  (bounding-circle [_] nil)
#+END_SRC

*** TODO ICenter
#+BEGIN_SRC clojure :noweb-ref impl
  g/ICenter
  (center
   ([_] nil)
   ([_ o] nil))
  (centroid [_])
#+END_SRC

*** TODO ICircumference
#+BEGIN_SRC clojure :noweb-ref impl
  g/ICircumference
  (circumference [_] nil)
#+END_SRC

*** TODO IGraph
#+BEGIN_SRC clojure :noweb-ref impl
  g/IVertexAccess
  (vertices
   [_ res]
   (first (sample-segments* res (get _ :segments))))
  g/IEdgeAccess
  (edges [_])
#+END_SRC

*** TODO IPolygonConvert
#+BEGIN_SRC clojure :noweb-ref impl
  g/IPolygonConvert
  (as-polygon
   ([_] nil)
   ([_ res] nil))
#+END_SRC

*** TODO ISample
#+BEGIN_SRC clojure :noweb-ref impl
  g/ISample
  (point-at [_ t])
  (random-point [_])
  (random-point-inside [_])
  (sample-uniform
   [_ udist include-last?]
   (->> _
        :segments
        (sample-segments* 8)
        (map #(gu/sample-uniform udist include-last? %))
        (first))) ;; TODO why first?
#+END_SRC

*** End of implementation                                          :noexport:
#+BEGIN_SRC clojure :noweb-ref impl
  )
#+END_SRC

** Namespace declaration

#+BEGIN_SRC clojure :tangle ../../babel/src/thi/ng/geom/path.cljc :noweb yes :mkdirp yes :padline no
  (ns thi.ng.geom.path
    (:require
     [thi.ng.math.core :as m]
     [thi.ng.geom.core :as g :refer [*resolution*]]
     [thi.ng.geom.vector :as v :refer [vec2]]
     [thi.ng.geom.utils :as gu]
     [thi.ng.geom.bezier :as b]
     [thi.ng.xerror.core :as err]
     #?(:clj [clojure.xml :as xml]))
    #?(:clj (:import [thi.ng.geom.types Line2 Path2])))

  <<ctors>>

  <<parser>>

  <<impl>>
#+END_SRC
